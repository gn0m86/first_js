undefined + 1;  // відповідь буде "NaN", тому що "undefined" не число і операцію складання неможна виконати

'true' == true  // відповідь буде "false", тому що строка залишиться строкою, тому що вона не може автоматично перетворюватися на булеве значення, тому
// різні типи даних в даному випадку при порівнянні повертається "false"

false == 'false'  // відповідь буде "false", тому що не може бути автоматичного перетворення з булевого в строку і навпаки, тому при порівнянні даних операндів буде "false"

null == ''  // відповідь буде "false", тому що null - це пустота, яка є окремим типом даних, а пуста строка '' також є типом даних строки, тому перетворення не можливе, а при 
// порівнянні різних типів даних поверне нам "false"

3 ** (9 / 3);  // відповідь буде число "27", тому що спочатку виконується те що в дужках (9/3=3), потім "3" в степені "3" = 27

!!'false' == !!'true'  // відповідь буде "true", тому що !!'false' є непорожнім рядком, перше заперечення ! зробить його false, а друге заперечення ! поверне його до true.
//Аналогічно буде з !!'true', повернеться true, а потім при порівнянні повертається true, тому що вони дорівнюють

0 || '0' && 1  // відповідь буде строка "0", тому що оператор && (логічне "І") має пріоритет над оператором АБО (||) і виконується першим, а результатом у нього повертається 
// перше хибне значення 0, а потім виконується операція || (АБО), де повертається перше істине значення для вираза 0 || '0', тому відповідь буде строка "0"

1 < 2 < 3  // відповідь буде "true", тому що рахується по порядку, спочатку 1 < 2 = true, потім true перетворюється на число 1 і виконується друге 1 < 3 = true, тому так

'foo'+ + +'bar'  // відповідь буде строка "fooNaN", тому що спочатку виконується унарний плюс +'bar', де результат буде NaN, тому що не можна перетворити його на число. 
// Далі унарний плюс для NaN - нічого не змінює для нього, залишається вираз 'foo' + NaN, де виконується конкатинація строк, тому буде строка "fooNaN"

3 ** 2 / 3;  // відповідь буде число "27", тому що оператори виконуються по черзі, спочатку в степінь 3**2=9, потім ділення 9/3=3, тому відповідь буде 3

1 < 2 > 3  // відповідь буде "false", тому що спочатку вирішується 1<2=true, потім true перетворюється в число 1 і виконується друга операція 1>3=false, тому відповідь false

(+null == false) < 1;  // відповідь буде "false", тому що спочатку виконується унарний плюс, що перетворює null на число 0, далі вирішується вираз 0==false в якому false = 0 
// і порівнюються 0==0, де відповіддю буде true, тепер маємо true<1, де true перетворюється на число 1 і маємо вираз 1<1, де отримуємо відповідь false. Тому відповідь буде false

false && true || true  // відповідь буде "true", тому що спочатку виконується вираз false&&true, де повертається перше хибне значення, тому false, а далі виконуємо вираз false || true
//  де цей оператор повертає перше true, тому відповідь буде true


false && (true || true);  // відповідь буде "false", тому що спочатку виконується вираз у дужках (true||true), де оператор АБО повертає перше істине значення true, далі виконується 
// вираз false&&true де логічний оператор І повертає перше хибне значення, а у нас це false

let ab = (+null == false) < 1 ** 5;  // відповідь буде "false", тому що спочатку виконується унарний оператор плюс, який перетворює null у число 0, далі маємо такий вираз 0==false, де false
//  перетворюється на число 0 і маємо 0==0 поверне true. Далі вираз має наступний вигляд true<1**5, де спочатку виконується возведення в степінь 1**5=1, а далі маємо такий вираз
//  true<1, де true перетворюється на число 1 і отже маємо 1<1=false
console.log(ab)